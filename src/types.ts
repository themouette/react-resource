import { AnyAction } from 'redux';

// List of all the implemented HTTP verbs
export enum HttpMethod {
    GET = 'GET',
    POST = 'POST',
    PUT = 'PUT',
    PATCH = 'PATCH',
    DELETE = 'DELETE'
}

export interface MiddlewareConfiguration {
    backend: string;
    fetchOptions: Partial<RequestInit>;
    /** default query params to apply for all requests */
    queryParams?: QueryString;
}

type QueryStringScalarParam = string | number | boolean | undefined | null;
export type QueryStringParam =
    | QueryStringScalarParam
    | QueryStringScalarParam[]
    | { [key: string]: QueryStringScalarParam | QueryStringScalarParam[] };
interface QueryStringObject {
    [param: string]: QueryStringParam | { [param: string]: QueryStringParam };
}
export type QueryString = string | QueryStringObject;

/** Type for fetch middleware response */
export interface FetchResponse<Data> {
    /** Response status code */
    status: number;
    /** Parsed data received from API */
    data: Data;
    /** The raw response as received from fetch */
    response: Response;
}

/* ==================== */
/* Action related types */
/* ==================== */

// List of all the possible action types
export enum ActionTypes {
    CONFIGURE = 'ddReduxResource/configure',
    FETCH = 'ddReduxResource/fetch'
}
export enum ResourceLifecycle {
    START = 'start',
    SUCCESS = 'success',
    FAILURE = 'failure'
}

// List of all possible Actions
export interface ActionConfigure extends AnyAction {
    type: ActionTypes.CONFIGURE;
    /** This field contains partial configuration to be applied */
    payload: Partial<MiddlewareConfiguration>;
}
export interface ActionFetchPayload {
    method: HttpMethod;
    path: string;
    backend?: string;
    fetchOptions?: Partial<RequestInit>;
}
export interface ActionFetch extends AnyAction {
    type: ActionTypes.FETCH;
    /** this field contains fetch configuration */
    payload: ActionFetchPayload;
}

export interface ActionFetchStart<T> extends AnyAction {
    /**
     * Type for this action is not known in advance
     * It will be generated by `createResource`
     */
    type: T;
    ddReduxResourceLifecycle: {
        lifecycle: ResourceLifecycle.START;
        requestId: string;
    };
}

export interface ActionFetchSuccess<T, R> extends AnyAction {
    /**
     * Type for this action is not known in advance
     * It will be generated by `createResource`
     */
    type: T;
    /** dd-redux-resource specific type */
    ddReduxResourceLifecycle: {
        lifecycle: ResourceLifecycle.SUCCESS;
        requestId: string;
    };
    /** API response */
    response: FetchResponse<R>;
}

export interface ActionFetchFailure<T, R> extends AnyAction {
    /**
     * Type for this action is not known in advance
     * It will be generated by `createResource`
     */
    type: T;
    /** dd-redux-resource specific type */
    ddReduxResourceLifecycle: {
        lifecycle: ResourceLifecycle.FAILURE;
        requestId: string;
    };
    /** API response */
    response: FetchResponse<R>;
}

export type ActionFetchLifecycle<R, E> =
    | ActionFetchStart<any>
    | ActionFetchSuccess<any, R>
    | ActionFetchFailure<any, E>;

/* ==================== */
/* State related types  */
/* ==================== */

export interface ConfigState {
    backend: string;
    queryParams?: QueryString;
    fetchOptions: Partial<RequestInit>;
}
// For now, we keep it simple and use a single array for every resource ids if
// performances are an issure, this can be separated per resource.
export interface ResourceState {
    isFetching: string[];
    isSuccess: string[];
    isFailure: string[];
}
export interface State {
    config: ConfigState;
    resources: ResourceState;
}
export const REDUCER_KEY = 'ddReduxResourceReducer';
export interface FullState {
    ddReduxResourceReducer: State;
}
